<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HTML5 Ad Viewer</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      text-align: center;
    }
    #drop-zone {
      border: 2px dashed #007bff;
      padding: 20px;
      margin-bottom: 10px;
      cursor: pointer;
      color: #555;
    }
    #share-button {
      margin-bottom: 20px;
      padding: 8px 16px;
      font-size: 1em;
      cursor: pointer;
    }
    #ads-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      justify-content: center;
    }
    iframe {
      border: none; /* Remove any borders */
      display: block;
    }
    /* Hide the file input element */
    #file-input {
      display: none;
    }
  </style>
</head>
<body>
  <h1>HTML5 Ad Viewer</h1>
  <div id="drop-zone">Drop your ZIP files here (or click to browse)</div>
  <button id="share-button">Share</button>
  <div id="ads-container"></div>
  <!-- Hidden file input for file browsing -->
  <input id="file-input" type="file" accept=".zip" multiple />

  <!-- Include JSZip from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    /**********************************
     * Global Variables and Helpers
     **********************************/
    // Array to store loaded ZIP File objects for sharing
    let loadedZipFiles = [];

    // Convert backslashes to forward slashes
    function normalizePath(path) {
      return path.replace(/\\/g, '/');
    }

    // Combine a base path and a relative path.
    // For example, combinePath("ad/", "images/photo.jpg") returns "ad/images/photo.jpg".
    function combinePath(basePath, relativePath) {
      relativePath = relativePath.replace(/^\/+/, '');
      return normalizePath(basePath + relativePath);
    }

    /**
     * Resolve a resource URL from a base path and a file map.
     * @param {string} basePath - The folder of the parent file.
     * @param {string} resourcePath - The resource path to resolve.
     * @param {Object} fileMap - Mapping of file paths to blob URLs.
     * @returns {string|null} A blob URL if found, or null.
     */
    function resolveResource(basePath, resourcePath, fileMap) {
      let candidate = null;
      if (resourcePath.startsWith('/')) {
        candidate = normalizePath(resourcePath.substring(1));
        if (fileMap[candidate]) return fileMap[candidate];
        candidate = combinePath(basePath, resourcePath);
        if (fileMap[candidate]) return fileMap[candidate];
      } else {
        candidate = combinePath(basePath, resourcePath);
        if (fileMap[candidate]) return fileMap[candidate];
        candidate = normalizePath(resourcePath);
        if (fileMap[candidate]) return fileMap[candidate];
      }
      console.warn("Resource not found for:", resourcePath, "Candidate tried:", candidate);
      return null;
    }

    // Convert a data URL (base64) to a Blob.
    function dataURLToBlob(dataUrl) {
      const arr = dataUrl.split(',');
      const mime = arr[0].match(/:(.*?);/)[1];
      const bstr = atob(arr[1]);
      let n = bstr.length;
      const u8arr = new Uint8Array(n);
      while (n--) {
        u8arr[n] = bstr.charCodeAt(n);
      }
      return new Blob([u8arr], { type: mime });
    }

    /**********************************
     * ZIP Processing Functionality
     **********************************/
    async function processZipFiles(files) {
      for (const file of files) {
        // file may be a File (from drag/drop or file input) or a Blob with a "name" property
        if (!file.name.endsWith('.zip')) {
          alert(`"${file.name}" is not a ZIP file. Skipping.`);
          continue;
        }
        try {
          const zip = new JSZip();
          // For shared files, our file is already a Blob; for dropped/browsed files, it's a File (a Blob)
          const zipContent = await zip.loadAsync(file.blob ? file.blob : file);

          // Build a mapping of normalized file paths to blob URLs.
          const fileMap = {};
          const nonCssPromises = [];
          const cssFiles = [];

          for (const [filename, fileData] of Object.entries(zipContent.files)) {
            if (!fileData.dir) {
              const normName = normalizePath(filename);
              if (normName.toLowerCase().endsWith('.css')) {
                cssFiles.push({ filename: normName, fileData });
              } else {
                nonCssPromises.push(
                  fileData.async("blob").then(blob => {
                    fileMap[normName] = URL.createObjectURL(blob);
                  })
                );
              }
            }
          }
          await Promise.all(nonCssPromises);

          // Process CSS files: update any url(...) references.
          const cssPromises = cssFiles.map(item => {
            const { filename, fileData } = item;
            return fileData.async("text").then(cssContent => {
              const lastSlashIndex = filename.lastIndexOf('/');
              const cssBasePath = lastSlashIndex !== -1 ? filename.substring(0, lastSlashIndex + 1) : '';
              cssContent = cssContent.replace(/url\(\s*(['"]?)([^'")]+)\1\s*\)/gi, (match, quote, resourcePath) => {
                if (/^(https?:|data:|\/\/)/i.test(resourcePath)) {
                  return match;
                }
                const blobURL = resolveResource(cssBasePath, resourcePath, fileMap);
                return blobURL ? `url("${blobURL}")` : match;
              });
              const blob = new Blob([cssContent], { type: "text/css" });
              fileMap[filename] = URL.createObjectURL(blob);
            });
          });
          await Promise.all(cssPromises);

          // Locate the index.html file (case-insensitive).
          const indexFile = Object.keys(fileMap).find(name => name.toLowerCase().endsWith('index.html'));
          if (!indexFile) {
            alert(`No index.html found in ZIP "${file.name}".`);
            continue;
          }

          // Read index.html as text for rewriting resource URLs.
          let indexContent = await zipContent.file(indexFile).async("text");
          const lastSlashIndex = indexFile.lastIndexOf('/');
          const htmlBasePath = lastSlashIndex !== -1 ? indexFile.substring(0, lastSlashIndex + 1) : '';

          // Replace src and href attributes.
          indexContent = indexContent.replace(/(src|href)=["']([^"']+)["']/gi, (match, attr, resourcePath) => {
            if (/^(https?:|data:|\/\/)/i.test(resourcePath)) {
              return match;
            }
            const blobURL = resolveResource(htmlBasePath, resourcePath, fileMap);
            return blobURL ? `${attr}="${blobURL}"` : match;
          });

          // Replace inline CSS url() references.
          indexContent = indexContent.replace(/url\(\s*(['"]?)([^'")]+)\1\s*\)/gi, (match, quote, resourcePath) => {
            if (/^(https?:|data:|\/\/)/i.test(resourcePath)) {
              return match;
            }
            const blobURL = resolveResource(htmlBasePath, resourcePath, fileMap);
            return blobURL ? `url("${blobURL}")` : match;
          });

          // Create a blob URL for the modified index.html.
          const modifiedBlob = new Blob([indexContent], { type: "text/html" });
          const modifiedUrl = URL.createObjectURL(modifiedBlob);

          // Create an iframe to display the ad.
          const iframe = document.createElement('iframe');
          iframe.src = modifiedUrl;
          iframe.title = file.name;
          iframe.onload = () => {
            setTimeout(() => {
              try {
                const doc = iframe.contentDocument.documentElement;
                iframe.style.width = doc.scrollWidth + 'px';
                iframe.style.height = doc.scrollHeight + 'px';
              } catch (err) {
                console.error("Error accessing iframe content:", err);
              }
            }, 100);
          };
          document.getElementById('ads-container').appendChild(iframe);
        } catch (err) {
          console.error(`Error processing "${file.name}":`, err);
          alert(`Error processing "${file.name}". See console for details.`);
        }
      }
    }

    /**********************************
     * Share Button Functionality
     **********************************/
    document.getElementById('share-button').addEventListener('click', async function () {
      if (loadedZipFiles.length === 0) {
        alert("No ZIP files loaded to share!");
        return;
      }
      const sharedFiles = [];
      for (const file of loadedZipFiles) {
        sharedFiles.push(new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = function (e) {
            resolve({
              name: file.name,
              data: e.target.result
            });
          };
          reader.onerror = function (e) {
            reject(e);
          };
          reader.readAsDataURL(file);
        }));
      }
      const sharedFilesData = await Promise.all(sharedFiles);
      const shareObj = { files: sharedFilesData };
      const shareStr = JSON.stringify(shareObj);
      const encodedShare = encodeURIComponent(shareStr);
      window.location.hash = "share=" + encodedShare;
      prompt("Copy this shareable link:", window.location.href);
    });

    /**********************************
     * Drag & Drop and File Browsing Handling
     **********************************/
    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-input');

    // When clicking the drop zone, open the file browser.
    dropZone.addEventListener('click', () => {
      fileInput.click();
    });

    // Drag & drop events.
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.style.borderColor = '#28a745';
    });
    dropZone.addEventListener('dragleave', () => {
      dropZone.style.borderColor = '#007bff';
    });
    dropZone.addEventListener('drop', async (e) => {
      e.preventDefault();
      dropZone.style.borderColor = '#007bff';
      const files = Array.from(e.dataTransfer.files);
      const zipFiles = files.filter(file => file.name.endsWith('.zip'));
      loadedZipFiles.push(...zipFiles);
      await processZipFiles(zipFiles);
    });

    // File browser selection event.
    fileInput.addEventListener('change', async (e) => {
      const files = Array.from(e.target.files);
      const zipFiles = files.filter(file => file.name.endsWith('.zip'));
      loadedZipFiles.push(...zipFiles);
      await processZipFiles(zipFiles);
      // Clear the file input for future selections.
      fileInput.value = "";
    });

    /**********************************
     * Load Shared Files from URL (if any)
     **********************************/
    async function loadSharedFilesFromURL() {
      const hash = window.location.hash;
      if (hash.startsWith("#share=")) {
        try {
          const encoded = hash.substring("#share=".length);
          const shareStr = decodeURIComponent(encoded);
          const shareObj = JSON.parse(shareStr);
          const sharedFilesData = shareObj.files; // Array of {name, data}
          const sharedFiles = sharedFilesData.map(fileData => {
            const blob = dataURLToBlob(fileData.data);
            blob.name = fileData.name;
            return blob;
          });
          loadedZipFiles.push(...sharedFiles);
          await processZipFiles(sharedFiles);
        } catch (err) {
          console.error("Error loading shared files from URL:", err);
        }
      }
    }

    window.addEventListener('load', () => {
      loadSharedFilesFromURL();
    });
  </script>
</body>
</html>
